---
title: Git分支模型及工作流
tags: 
  - Git
  - Summary
modify_date: 2020-02-20
---

## 分支模型

### 典型分支模型

<!--more-->

* A successful Git branching model
  ![](https://backlog.com/git-tutorial/cn/img/post/stepup/capture_stepup1_5_6.png)

> #### 主分支
>
> 主分支有两种：master分支和develop分支
>
> - **master**
>   master分支只负责管理发布的状态。在提交时使用标签记录发布版本号。
> - **develop**
>   develop分支是针对发布的日常开发分支。刚才我们已经讲解过有合并分支的功用。
>
> #### 特性分支
>
> 特性分支就是我们在前面讲解过的topic分支的功用。
>
> 这个分支是针对新功能的开发，在bug修正的时候从develop分支分叉出来的。基本上不需要共享特性分支的操作，所以不需要远端控制。完成开发后，把分支合并回develop分支后发布。
>
> #### release分支
>
> release分支是为release做准备的。通常会在分支名称的最前面加上release-。release前需要在这个分支进行最后的调整，而且为了下一版release开发用develop分支的上游分支。
>
> 一般的开发是在develop分支上进行的，到了可以发布的状态时再创建release分支，为release做最后的bug修正。
>
> 到了可以release的状态时，把release分支合并到master分支，并且在合并提交里添加release版本号的标签。
>
> 要导入在release分支所作的修改，也要合并回develop分支。
>
> #### hotFix分支
>
> hotFix分支是在发布的产品需要紧急修正时，从master分支创建的分支。通常会在分支名称的最前面加上 hotfix-。
>
> 例如，在develop分支上的开发还不完整时，需要紧急修改。这个时候在develop分支创建可以发布的版本要花许多的时间，所以最好选择从master分支直接创建分支进行修改，然后合并分支。
>
> 修改时创建的hotFix分支要合并回develop分支。

* 长期分支

>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。
>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。
>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。
>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。
>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 next 或者 master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。

* 特性分支

>特性分支对任何规模的项目都适用。 特性分支是一种短期分支，它被用来实现单一特性或其相关工作。 也许你从来没有在其他的版本控制系统（VCS）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。
>然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见。
>你已经在上一节中你创建的 iss53 和 hotfix 特性分支中看到过这种用法。 你在上一节用到的特性分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。

![image-20191120195107711](https://i.loli.net/2020/05/17/eAlEZOu9mIrchMQ.png)

<img src="https://i.loli.net/2020/05/17/2OMgCaAIV6KlwZE.png" alt="image-20191120195557781" style="zoom:80%;" />


## 工作流


### 集中式工作流

>集中式系统中通常使用的是单点协作模型——集中式工作流。一个中心集线器，或者说仓库，可以接受代码，所有人将自己的工作与之同步。若干个开发者则作为节点——也就是中心仓库的消费者——并且与其进行同步。
>这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。这和 Subversion （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。
>如果在公司或者团队中，你已经习惯了使用这种集中式工作流程，完全可以继续采用这种简单的模式。只需要搭建好一个中心仓库，并给开发团队中的每个人推送数据的权限，就可以开展工作了。Git 不会让用户覆盖彼此的修改。 例如John和Jessica同时开始工作。John完成了他的修改并推送到服务器。接着Jessica尝试提交她自己的修改，却遭到服务器拒绝。她被告知她的修改正通过非快进式（non-fast-forward）的方式推送，只有将数据抓取下来并且合并后方能推送。 这种模式的工作流程的使用非常广泛，因为大多数人对其很熟悉也很习惯。
>当然这并不局限于小团队。利用 Git 的分支模型，通过同时在多个分支上工作的方式，即使是上百人的开发团队也可以很好地在单个项目上协作。

<img src="https://i.loli.net/2020/05/17/yrPSEmUMOg2T9fH.png" alt="image-20191120204515440" style="zoom:67%;" />

### 集成管理者工作流

>Git允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。这种情形下通常会有个代表“官方”项目的权威的仓库。要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。接着你可以请求官方仓库的维护者拉取更新合并到主项目。维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。这一流程的工作方式如下所示：
>
>1. 项目维护者推送到主仓库。
>2. 贡献者克隆此仓库，做出修改。
>3. 贡献者将数据推送到自己的公开仓库。
>4. 贡献者给维护者发送邮件，请求拉取自己的更新。
>5. 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。
>6. 维护者将合并后的修改推送到主仓库。
>
>这是 GitHub 和 GitLab 等集线器式（hub-based）工具最常用的工作流程。人们可以容易地将某个项目派生成为自己的公开仓库，向这个仓库推送自己的修改，并为每个人所见。这么做最主要的优点之一是你可以持续地工作，而主仓库的维护者可以随时拉取你的修改。贡献者不必等待维护者处理完提交的更新——每一方都可以按照自己的节奏工作。

<img src="https://i.loli.net/2020/05/17/YcuxWlEndbAGs6i.png" alt="image-20191120204554211" style="zoom:80%;" />

### 司令官与副官工作流

>这其实是多仓库工作流程的变种。一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。被称为副官（lieutenant）的各个集成管理者分别负责集成项目中的特定部分。所有这些副官头上还有一位称为司令官（dictator）的总集成管理者负责统筹。司令官维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。整个流程看起来是这样的（见 司令官与副官工作流。 ）：
>
>1. 普通开发者在自己的特性分支上工作，并根据 master 分支进行变基。 这里是司令官的 master 分支。
>2. 副官将普通开发者的特性分支合并到自己的 master 分支中。
>3. 司令官将所有副官的 master 分支并入自己的 master 分支中。
>4. 司令官将集成后的 master 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基。
>
>这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优势。利用这种方式，项目总负责人（即司令官）可以把大量分散的集成工作委托给不同的小组负责人分别处理，然后在不同时刻将大块的代码子集统筹起来，用于之后的整合。

<img src="https://i.loli.net/2020/05/17/49qbWgPHdmUX8CZ.png" alt="image-20191120204618572" style="zoom:80%;" />

## 向一个项目贡献


* 高内聚的提交
* 详细的注释，有摘要与正文
* 在一个你不是维护者的项目上，通常有一个总是跟踪origin/master的master分支会很方便，确保你的更新可以快进合并到远程仓库的master分支上